package dev.vulnlog.suppression

import dev.vulnlog.common.AnalysisDataPerBranch
import dev.vulnlog.common.ExecutionDataPerBranch
import dev.vulnlog.common.ReleaseBranchDataImpl
import dev.vulnlog.common.ReportDataPerBranch
import dev.vulnlog.common.SuppressionPermanentExecutionPerBranch
import dev.vulnlog.common.TaskDataPerBranch
import dev.vulnlog.common.VulnerabilityDataPerBranch
import dev.vulnlog.dsl.ReleaseBranchData
import dev.vulnlog.dsl.ResultStatus
import dev.vulnlog.dsl.VlReporterConfig
import dev.vulnlog.dsl.VlReporterImpl
import dev.vulnlog.dsl.WaitAction
import dev.vulnlog.dsl.days
import dev.vulnlog.dsl.high
import io.kotest.core.spec.style.FunSpec
import io.kotest.matchers.shouldBe
import io.mockk.every
import io.mockk.mockk
import java.time.LocalDate

class VulnerabilitySplitterServiceTest : FunSpec({
    val service = VulnerabilitySplitterService()
    val someBranch: ReleaseBranchData = ReleaseBranchDataImpl("some branch")
    val reporterA = VlReporterImpl("Reporter A", mockk<VlReporterConfig>())

    test("empty input should result into empty output") {
        val result = service.split(emptyList())

        result shouldBe emptyList()
    }

    test("empty vulnerabilities input should result into empty output") {
        val result = service.split(listOf(SplitterInput(someBranch, emptyList())))

        result shouldBe emptyList()
    }

    test("ignore reporter without a config") {
        val reportDataPerBranch = mockk<ReportDataPerBranch>()
        every { reportDataPerBranch.reporters } returns setOf(VlReporterImpl("Reporter A", null))
        val vulnPerBranch = mockk<VulnerabilityDataPerBranch>()
        every { vulnPerBranch.reportData } returns reportDataPerBranch

        val result = service.split(listOf(SplitterInput(someBranch, listOf(vulnPerBranch))))

        result shouldBe emptyList()
    }

    test("split one ID into one vulnerabilities") {
        val vulnPerBranch =
            VulnerabilityDataPerBranch(
                branch = someBranch,
                ids = listOf("CVE-2025-0001"),
                status = ResultStatus.AFFECTED,
                reportData = ReportDataPerBranch(setOf(reporterA), LocalDate.now()),
                analysisData = AnalysisDataPerBranch(LocalDate.now(), high, "some reasoning"),
                taskData = TaskDataPerBranch(WaitAction(42.days)),
                executionData = ExecutionDataPerBranch(SuppressionPermanentExecutionPerBranch),
            )

        val result = service.split(listOf(SplitterInput(someBranch, listOf(vulnPerBranch))))

        val expected1 =
            SuppressVulnerability(
                id = "CVE-2025-0001",
                status = ResultStatus.AFFECTED,
                reporter = reporterA,
                reportDate = LocalDate.now(),
                analysisReasoning = "some reasoning",
                suppressType = SuppressionPermanentExecutionPerBranch,
                suppressUntilDate = null,
            )

        result shouldBe listOf(MapperInput(someBranch, mapOf(reporterA to listOf(expected1))))
    }

    test("split two IDs into two vulnerabilities") {
        val vulnPerBranch =
            VulnerabilityDataPerBranch(
                branch = someBranch,
                ids = listOf("CVE-2025-0001", "CVE-2025-0002"),
                status = ResultStatus.AFFECTED,
                reportData = ReportDataPerBranch(setOf(reporterA), LocalDate.now()),
                analysisData = AnalysisDataPerBranch(LocalDate.now(), high, "some reasoning"),
                taskData = TaskDataPerBranch(WaitAction(42.days)),
                executionData = ExecutionDataPerBranch(SuppressionPermanentExecutionPerBranch),
            )

        val result = service.split(listOf(SplitterInput(someBranch, listOf(vulnPerBranch))))

        val expected1 =
            SuppressVulnerability(
                id = "CVE-2025-0001",
                status = ResultStatus.AFFECTED,
                reporter = reporterA,
                reportDate = LocalDate.now(),
                analysisReasoning = "some reasoning",
                suppressType = SuppressionPermanentExecutionPerBranch,
                suppressUntilDate = null,
            )
        val expected2 =
            SuppressVulnerability(
                id = "CVE-2025-0002",
                status = ResultStatus.AFFECTED,
                reporter = reporterA,
                reportDate = LocalDate.now(),
                analysisReasoning = "some reasoning",
                suppressType = SuppressionPermanentExecutionPerBranch,
                suppressUntilDate = null,
            )

        result shouldBe listOf(MapperInput(someBranch, mapOf(reporterA to listOf(expected1, expected2))))
    }
})
