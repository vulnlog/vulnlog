package dev.vulnlog.suppression

import dev.vulnlog.common.SuppressionDateExecutionPerBranch
import dev.vulnlog.common.SuppressionEventExecutionPerBranch
import dev.vulnlog.common.SuppressionPermanentExecutionPerBranch
import dev.vulnlog.common.model.BranchName
import dev.vulnlog.common.model.VulnId
import dev.vulnlog.common.model.VulnStatusAffected
import dev.vulnlog.common.model.VulnStatusFixed
import dev.vulnlog.common.model.VulnStatusNotAffected
import dev.vulnlog.common.model.VulnStatusUnderInvestigation
import dev.vulnlog.common.model.VulnStatusUnknown
import io.kotest.core.spec.style.FunSpec
import io.kotest.matchers.collections.shouldContain
import io.kotest.matchers.collections.shouldContainExactly
import io.kotest.matchers.shouldBe
import io.mockk.every
import io.mockk.mockk
import java.time.LocalDate

class SuppressionVulnerabilityMapperServiceTest : FunSpec({
    val service = SuppressionVulnerabilityMapperService()
    val someBranch = BranchName("some branch")
    val reporterA = "Reporter A"
    val reporterB = "Reporter B"
    val vulnerability1 =
        SuppressVulnerability(
            id = VulnId("CVE-2025-0001"),
            status = VulnStatusAffected,
            reporter = reporterA,
            reportDate = LocalDate.now().minusDays(1),
            analysisReasoning = "some reasoning",
            suppressType = SuppressionPermanentExecutionPerBranch,
            suppressionStart = LocalDate.now().minusDays(1),
            suppressionEnd = LocalDate.now().plusDays(1),
        )
    val vulnerability2 =
        SuppressVulnerability(
            id = VulnId("CVE-2025-0002"),
            status = VulnStatusAffected,
            reporter = reporterA,
            reportDate = LocalDate.now().minusDays(1),
            analysisReasoning = "some reasoning",
            suppressType = SuppressionPermanentExecutionPerBranch,
            suppressionStart = LocalDate.now().minusDays(1),
            suppressionEnd = LocalDate.now().plusDays(1),
        )

    test("empty input should result into empty output") {
        val result = service.mapToRelevantVulnerabilities(emptyList())

        result shouldBe emptySet()
    }

    test("empty vulnerabilities input should result into empty output") {
        val input = listOf(MapperInput(someBranch, emptyMap()))

        val result = service.mapToRelevantVulnerabilities(input)

        result shouldBe emptySet()
    }

    test("ignore if null suppression type") {
        val vulnerability = mockk<SuppressVulnerability>()
        every { vulnerability.suppressType } returns null
        val input = listOf(MapperInput(someBranch, mapOf(reporterA to listOf(vulnerability))))

        val result = service.mapToRelevantVulnerabilities(input)

        result shouldBe emptySet()
    }

    listOf(VulnStatusFixed, VulnStatusNotAffected, VulnStatusUnderInvestigation, VulnStatusUnknown)
        .forEach { status ->
            test("ignore if status is $status") {
                val vulnerability = mockk<SuppressVulnerability>()
                every { vulnerability.status } returns status
                every { vulnerability.suppressType } returns SuppressionPermanentExecutionPerBranch
                every { vulnerability.suppressionEnd } returns LocalDate.now().minusDays(3)
                val input = listOf(MapperInput(someBranch, mapOf(reporterA to listOf(vulnerability))))

                val result = service.mapToRelevantVulnerabilities(input)

                result shouldBe emptySet()
            }
        }

    test("ignore if suppress until is today") {
        val vulnerability = mockk<SuppressVulnerability>()
        every { vulnerability.status } returns VulnStatusAffected
        every { vulnerability.suppressType } returns SuppressionPermanentExecutionPerBranch
        every { vulnerability.suppressionEnd } returns LocalDate.now()
        val input = listOf(MapperInput(someBranch, mapOf(reporterA to listOf(vulnerability))))

        val result = service.mapToRelevantVulnerabilities(input)

        result shouldBe emptySet()
    }

    test("ignore if suppress until is in the past") {
        val vulnerability = mockk<SuppressVulnerability>()
        every { vulnerability.status } returns VulnStatusAffected
        every { vulnerability.suppressType } returns SuppressionPermanentExecutionPerBranch
        every { vulnerability.suppressionEnd } returns LocalDate.now().minusDays(1)
        val input = listOf(MapperInput(someBranch, mapOf(reporterA to listOf(vulnerability))))

        val result = service.mapToRelevantVulnerabilities(input)

        result shouldBe emptySet()
    }

    test("should find single vulnerability in single reporter") {
        val input = listOf(MapperInput(someBranch, mapOf(reporterA to listOf(vulnerability1))))

        val result = service.mapToRelevantVulnerabilities(input)

        result shouldContainExactly setOf(VulnsPerBranchAndRecord(someBranch, reporterA, setOf(vulnerability1)))
    }

    listOf(
        VulnStatusNotAffected,
        VulnStatusUnderInvestigation,
        VulnStatusUnknown,
        VulnStatusAffected,
    ).forEach { status ->
        test("should find vulnerability with status $status in single reporter") {
            val vulnerability = vulnerability1.copy(status = status)
            val input = listOf(MapperInput(someBranch, mapOf(reporterA to listOf(vulnerability))))

            val result = service.mapToRelevantVulnerabilities(input)

            result shouldContainExactly setOf(VulnsPerBranchAndRecord(someBranch, reporterA, setOf(vulnerability)))
        }
    }

    test("should nod find vulnerability with status $VulnStatusFixed in single reporter") {
        val vulnerability = vulnerability1.copy(status = VulnStatusFixed)
        val input = listOf(MapperInput(someBranch, mapOf(reporterA to listOf(vulnerability))))

        val result = service.mapToRelevantVulnerabilities(input)

        result shouldContainExactly emptySet()
    }

    test("should find two vulnerability in single reporter") {
        val input = listOf(MapperInput(someBranch, mapOf(reporterA to listOf(vulnerability1, vulnerability2))))

        val result = service.mapToRelevantVulnerabilities(input)

        val expected =
            setOf(
                VulnsPerBranchAndRecord(
                    someBranch,
                    reporterA,
                    setOf(vulnerability1, vulnerability2),
                ),
            )
        result shouldContainExactly expected
    }

    test("should find single vulnerability per reporter") {
        val input =
            listOf(
                MapperInput(
                    someBranch,
                    mapOf(
                        reporterA to listOf(vulnerability1),
                        reporterB to listOf(vulnerability1.copy(reporter = reporterB)),
                    ),
                ),
            )

        val result = service.mapToRelevantVulnerabilities(input)

        val expected =
            setOf(
                VulnsPerBranchAndRecord(someBranch, reporterA, setOf(vulnerability1)),
                VulnsPerBranchAndRecord(someBranch, reporterB, setOf(vulnerability1.copy(reporter = reporterB))),
            )
        result shouldContainExactly expected
    }

    listOf(
        SuppressionPermanentExecutionPerBranch,
        SuppressionDateExecutionPerBranch(LocalDate.now().plusDays(1)),
        SuppressionEventExecutionPerBranch,
    ).forEach { suppressionType ->
        test("should find single vulnerability for suppression type: ${suppressionType.javaClass.simpleName}") {
            val input =
                listOf(
                    MapperInput(
                        someBranch,
                        mapOf(
                            reporterA to listOf(vulnerability1.copy(suppressType = suppressionType)),
                        ),
                    ),
                )

            val result = service.mapToRelevantVulnerabilities(input)

            val expected =
                VulnsPerBranchAndRecord(
                    someBranch,
                    reporterA,
                    setOf(vulnerability1.copy(suppressType = suppressionType)),
                )
            result shouldContain expected
        }
    }
})
