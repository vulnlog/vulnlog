package dev.vulnlog.suppression

import dev.vulnlog.common.ReleaseBranchDataImpl
import dev.vulnlog.common.SuppressionDateExecutionPerBranch
import dev.vulnlog.common.SuppressionEventExecutionPerBranch
import dev.vulnlog.common.SuppressionPermanentExecutionPerBranch
import dev.vulnlog.dsl.ReleaseBranchData
import dev.vulnlog.dsl.ResultStatus
import dev.vulnlog.dsl.VlReporterImpl
import io.kotest.core.spec.style.FunSpec
import io.kotest.matchers.collections.shouldContain
import io.kotest.matchers.collections.shouldContainExactly
import io.kotest.matchers.shouldBe
import io.mockk.every
import io.mockk.mockk
import java.time.LocalDate

class SuppressionVulnerabilityMapperServiceTest : FunSpec({
    val service = SuppressionVulnerabilityMapperService()
    val someBranch: ReleaseBranchData = ReleaseBranchDataImpl("some branch")
    val reporterA = VlReporterImpl("Reporter A")
    val reporterB = VlReporterImpl("Reporter B")
    val vulnerability1 =
        SuppressVulnerability(
            id = "CVE-2025-0001",
            status = ResultStatus.AFFECTED,
            reporter = reporterA,
            reportDate = LocalDate.now().minusDays(1),
            analysisReasoning = "some reasoning",
            suppressType = SuppressionPermanentExecutionPerBranch,
            suppressUntilDate = LocalDate.now().plusDays(1),
        )
    val vulnerability2 =
        SuppressVulnerability(
            id = "CVE-2025-0002",
            status = ResultStatus.AFFECTED,
            reporter = reporterA,
            reportDate = LocalDate.now().minusDays(1),
            analysisReasoning = "some reasoning",
            suppressType = SuppressionPermanentExecutionPerBranch,
            suppressUntilDate = LocalDate.now().plusDays(1),
        )

    test("empty input should result into empty output") {
        val result = service.mapToRelevantVulnerabilities(emptyList())

        result shouldBe emptySet()
    }

    test("empty vulnerabilities input should result into empty output") {
        val input = listOf(MapperInput(someBranch, emptyMap()))

        val result = service.mapToRelevantVulnerabilities(input)

        result shouldBe emptySet()
    }

    test("ignore if null suppression type") {
        val vulnerability = mockk<SuppressVulnerability>()
        every { vulnerability.suppressType } returns null
        val input = listOf(MapperInput(someBranch, mapOf(reporterA to listOf(vulnerability))))

        val result = service.mapToRelevantVulnerabilities(input)

        result shouldBe emptySet()
    }

    ResultStatus.entries.filterNot { it == ResultStatus.AFFECTED }.forEach { status ->
        test("ignore if status is $status") {
            val vulnerability = mockk<SuppressVulnerability>()
            every { vulnerability.status } returns status
            every { vulnerability.suppressType } returns SuppressionPermanentExecutionPerBranch
            every { vulnerability.suppressUntilDate } returns LocalDate.now().minusDays(3)
            val input = listOf(MapperInput(someBranch, mapOf(reporterA to listOf(vulnerability))))

            val result = service.mapToRelevantVulnerabilities(input)

            result shouldBe emptySet()
        }
    }

    test("ignore if suppress until is today") {
        val vulnerability = mockk<SuppressVulnerability>()
        every { vulnerability.status } returns ResultStatus.AFFECTED
        every { vulnerability.suppressType } returns SuppressionPermanentExecutionPerBranch
        every { vulnerability.suppressUntilDate } returns LocalDate.now()
        val input = listOf(MapperInput(someBranch, mapOf(reporterA to listOf(vulnerability))))

        val result = service.mapToRelevantVulnerabilities(input)

        result shouldBe emptySet()
    }

    test("ignore if suppress until is in the past") {
        val vulnerability = mockk<SuppressVulnerability>()
        every { vulnerability.status } returns ResultStatus.AFFECTED
        every { vulnerability.suppressType } returns SuppressionPermanentExecutionPerBranch
        every { vulnerability.suppressUntilDate } returns LocalDate.now().minusDays(1)
        val input = listOf(MapperInput(someBranch, mapOf(reporterA to listOf(vulnerability))))

        val result = service.mapToRelevantVulnerabilities(input)

        result shouldBe emptySet()
    }

    test("should find single vulnerability in single reporter") {
        val input = listOf(MapperInput(someBranch, mapOf(reporterA to listOf(vulnerability1))))

        val result = service.mapToRelevantVulnerabilities(input)

        result shouldContainExactly setOf(VulnsPerBranchAndRecord(someBranch, reporterA, setOf(vulnerability1)))
    }

    test("should find two vulnerability in single reporter") {
        val input = listOf(MapperInput(someBranch, mapOf(reporterA to listOf(vulnerability1, vulnerability2))))

        val result = service.mapToRelevantVulnerabilities(input)

        val expected =
            setOf(
                VulnsPerBranchAndRecord(
                    someBranch,
                    reporterA,
                    setOf(vulnerability1, vulnerability2),
                ),
            )
        result shouldContainExactly expected
    }

    test("should find single vulnerability per reporter") {
        val input =
            listOf(
                MapperInput(
                    someBranch,
                    mapOf(
                        reporterA to listOf(vulnerability1),
                        reporterB to listOf(vulnerability1.copy(reporter = reporterB)),
                    ),
                ),
            )

        val result = service.mapToRelevantVulnerabilities(input)

        val expected =
            setOf(
                VulnsPerBranchAndRecord(someBranch, reporterA, setOf(vulnerability1)),
                VulnsPerBranchAndRecord(someBranch, reporterB, setOf(vulnerability1.copy(reporter = reporterB))),
            )
        result shouldContainExactly expected
    }

    listOf(
        SuppressionPermanentExecutionPerBranch,
        SuppressionDateExecutionPerBranch(LocalDate.now().plusDays(1)),
        SuppressionEventExecutionPerBranch(LocalDate.now().plusDays(1)),
    ).forEach { suppressionType ->
        test("should find single vulnerability for suppression type: ${suppressionType.javaClass.simpleName}") {
            val input =
                listOf(
                    MapperInput(
                        someBranch,
                        mapOf(
                            reporterA to listOf(vulnerability1.copy(suppressType = suppressionType)),
                        ),
                    ),
                )

            val result = service.mapToRelevantVulnerabilities(input)

            val expected =
                VulnsPerBranchAndRecord(
                    someBranch,
                    reporterA,
                    setOf(vulnerability1.copy(suppressType = suppressionType)),
                )
            result shouldContain expected
        }
    }
})
