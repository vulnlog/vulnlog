package dev.vulnlog.suppression

import dev.vulnlog.common.ExecutionPerBranch
import dev.vulnlog.common.SuppressionExecution
import dev.vulnlog.common.VulnerabilityDataPerBranch
import dev.vulnlog.dsl.ReleaseBranchData
import dev.vulnlog.dsl.VlReporter
import dev.vulnlog.dsl.VlReporterImpl

data class SplitterInput(
    val releaseBranch: ReleaseBranchData,
    val vulnerabilities: List<VulnerabilityDataPerBranch>,
)

/**
 * Service responsible for splitting and organizing vulnerability data per branch and reporter.
 * Processes input vulnerability data and transforms it into structured mappings between branches
 * and their respective vulnerabilities grouped by reporter.
 */
class VulnerabilitySplitterService {
    /**
     * Splits the given list of `SplitterInput` objects into a list of `MapperInput` objects by processing
     * and grouping vulnerabilities per reporter.
     *
     * The method involves replicating and grouping vulnerabilities by their identifiers and their respective reporters,
     * splitting the grouped vulnerabilities by reporters, filtering out empty groups, and formatting the result
     * as `MapperInput` objects.
     *
     * @param splitterInput The list of input data containing branch-specific vulnerabilities to be split and processed.
     * Each entry correlates release branch information with a list of associated vulnerabilities.
     *
     * @return A list of `MapperInput` objects. Each object contains release branch data and a mapping of reporters
     * to their associated and processed vulnerabilities grouped by reporter.
     */
    fun split(splitterInput: List<SplitterInput>): List<MapperInput> =
        splitterInput
            .map { (branch, vulns) -> branch to vulns.map { vuln -> replicateVulnPerIdAndGroupByReporter(vuln) } }
            .map { (branch, vulns) -> branch to splitVulnsPerReporter(vulns) }
            .filter { (_, vulns) -> vulns.isNotEmpty() }
            .map { (branch, vulns) -> MapperInput(branch, vulns) }

    private fun replicateVulnPerIdAndGroupByReporter(
        vuln: VulnerabilityDataPerBranch,
    ): Map<VlReporter, List<VulnerabilityDataPerBranch>> =
        vuln.reportData.reporters
            .filterIsInstance<VlReporterImpl>()
            .filter { it.config != null }
            .map { reporter -> reporter to cloneWithSingleId(vuln) }
            .toMap()

    private fun cloneWithSingleId(vuln: VulnerabilityDataPerBranch): List<VulnerabilityDataPerBranch> {
        return vuln.ids.map { id -> vuln.copy(ids = listOf(id)) }
    }

    private fun splitVulnsPerReporter(
        vulns: List<Map<VlReporter, List<VulnerabilityDataPerBranch>>>,
    ): Map<VlReporter, List<SuppressVulnerability>> {
        return vulns
            .filter { it.isNotEmpty() }
            .flatMap { it.entries }
            .groupBy({ it.key }, { it.value })
            .mapValues { (_, lists) ->
                lists.flatten()
                    .filter { it.executionData?.execution is SuppressionExecution }
                    .map(::toSuppressVulnerability)
            }
    }

    private fun toSuppressVulnerability(vuln: VulnerabilityDataPerBranch): SuppressVulnerability {
        val execution: ExecutionPerBranch? = vuln.executionData?.execution
        return SuppressVulnerability(
            id = vuln.ids[0],
            status = vuln.status,
            reporter = vuln.reportData.reporters.first(),
            reportDate = vuln.reportData.awareAt,
            analysisReasoning = vuln.analysisData?.reasoning!!,
            suppressType = execution as SuppressionExecution,
            suppressUntilDate = execution.suppressUntilDate,
        )
    }
}
