package dev.vulnlog.dsl.impl

import dev.vulnlog.dsl.ReleaseBranch
import dev.vulnlog.dsl.ReleaseBranchData
import dev.vulnlog.dsl.ReleaseBranchDataImpl
import dev.vulnlog.dsl.TaskAction
import dev.vulnlog.dsl.TaskDataImpl
import dev.vulnlog.dsl.VlVulnerabilityContext
import dev.vulnlog.dsl.VlVulnerabilityDslRoot
import dev.vulnlog.dsl.VulnlogAnalysisData
import dev.vulnlog.dsl.VulnlogAnalysisDataEmpty
import dev.vulnlog.dsl.VulnlogAnalysisDataImpl
import dev.vulnlog.dsl.VulnlogData
import dev.vulnlog.dsl.VulnlogExecutionData
import dev.vulnlog.dsl.VulnlogExecutionDataEmpty
import dev.vulnlog.dsl.VulnlogExecutionDataImpl
import dev.vulnlog.dsl.VulnlogReportData
import dev.vulnlog.dsl.VulnlogReportDataEmpty
import dev.vulnlog.dsl.VulnlogReportDataImpl
import dev.vulnlog.dsl.VulnlogTaskData
import dev.vulnlog.dsl.VulnlogTaskDataEmpty
import dev.vulnlog.dsl.VulnlogTaskDataImpl

class VlVulnerabilityDslRootImpl : VlVulnerabilityDslRoot {
    override val data = mutableListOf<VulnlogData>()

    override fun vuln(
        id: String,
        block: VlVulnerabilityContext.() -> Unit,
    ): VulnlogData = createVulnlogData(listOf(id), block)

    override fun vuln(
        vararg id: String,
        block: VlVulnerabilityContext.() -> Unit,
    ): VulnlogData = createVulnlogData(id.toList(), block)

    private fun createVulnlogData(
        id: List<String>,
        block: VlVulnerabilityContext.() -> Unit,
    ): VulnlogData =
        with(VlVulnerabilityContext()) {
            block()

            val reportData = aBuilder.value.reportData
            val analysisData = tBuilder.value.analysisData
            val taskData = eBuilder.value.taskData
            val executionData = eBuilder.value.build()

            val report: VulnlogReportData =
                if (reportData.scanner.isBlank()) {
                    VulnlogReportDataEmpty
                } else {
                    VulnlogReportDataImpl(
                        reportData.scanner,
                        reportData.awareOfAt,
                        reportData.affectedReleases.map { ReleaseBranchDataImpl(it.name) },
                    )
                }

            val analysis: VulnlogAnalysisData =
                if (analysisData.verdict.isBlank()) {
                    VulnlogAnalysisDataEmpty
                } else {
                    VulnlogAnalysisDataImpl(analysisData.analysedAt, analysisData.verdict, analysisData.reasoning)
                }

            val task: VulnlogTaskData =
                if (taskData.tasks.isEmpty()) {
                    VulnlogTaskDataEmpty
                } else {
                    val taskActionsToReleaseBranches: Map<TaskAction, List<ReleaseBranchData>> =
                        taskData.tasks.associate { task ->
                            task.taskAction to task.releases.map(ReleaseBranch::name).map(::ReleaseBranchDataImpl)
                        }
                    VulnlogTaskDataImpl(taskActionsToReleaseBranches)
                }

            val execution: VulnlogExecutionData =
                if (executionData.taskData.tasks.isEmpty()) {
                    VulnlogExecutionDataEmpty
                } else {
                    val taskData2 =
                        executionData.taskData.tasks
                            .map { t ->
                                TaskDataImpl(
                                    t.taskAction,
                                    t.releases.map(ReleaseBranch::name).map(::ReleaseBranchDataImpl),
                                )
                            }
                    VulnlogExecutionDataImpl(taskData2)
                }

            val vulnlogData = VulnlogData(id, report, analysis, task, execution)
            data += vulnlogData
            vulnlogData
        }
}
