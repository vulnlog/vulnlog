package io.vulnlog.dsl.impl

import io.vulnlog.dsl.VlActionContext
import io.vulnlog.dsl.VlFixActionTargetDependencyBuilder
import io.vulnlog.dsl.VlFixActionTargetVersionBuilder
import io.vulnlog.dsl.VlOverwriteBuilder
import io.vulnlog.dsl.VlRatingValue
import io.vulnlog.dsl.VlReleaseValue
import io.vulnlog.dsl.VlReportByValue
import io.vulnlog.dsl.VlReportForValue
import io.vulnlog.dsl.VlReporterValue
import io.vulnlog.dsl.VlVariantValue
import io.vulnlog.dsl.VlVulnerabilityContext
import io.vulnlog.dsl.VlVulnerabilityValue
import java.time.LocalDate

@Suppress("TooManyFunctions")
internal class VlVulnerabilityContextImpl : VlVulnerabilityContext, VlVulnerabilityContextBuilder {
    private var reportFor: Set<VlReportForValue> = emptySet()
    private var reportBy: Set<VlReportByValue> = emptySet()
    private var rating: VlRatingValue? = null
    private var toFix: VlToFixActionBuilder? = null
    private var fixIn: Set<VlReleaseValue> = emptySet()

    private val actionContext: MutableList<VlActionContext> = mutableListOf()

    override fun reportFor(
        variant: VlVariantValue,
        vararg versions: VlReleaseValue,
    ) {
        reportFor = versions.map { VlReportForValueImpl(variant, it) }.toSet()
    }

    override fun reportBy(vararg reporters: VlReporterValue) {
        reportBy = reporters.map(VlReporterValue::name).map(::VlReportByValueImpl).toSet()
    }

    override fun critical(
        dateOfAnalysing: String,
        reasoning: String,
    ) {
        val parsedDateOfAnalysing: LocalDate = LocalDate.parse(dateOfAnalysing)
        rating = VlRatingCriticalValueImpl(parsedDateOfAnalysing, reasoning)
    }

    override fun high(
        dateOfAnalysing: String,
        reasoning: String,
    ) {
        val parsedDateOfAnalysing: LocalDate = LocalDate.parse(dateOfAnalysing)
        rating = VlRatingHighValueImpl(parsedDateOfAnalysing, reasoning)
    }

    override fun moderate(
        dateOfAnalysing: String,
        reasoning: String,
    ) {
        val parsedDateOfAnalysing: LocalDate = LocalDate.parse(dateOfAnalysing)
        rating = VlRatingModerateValueImpl(parsedDateOfAnalysing, reasoning)
    }

    override fun low(
        dateOfAnalysing: String,
        reasoning: String,
    ) {
        val parsedDateOfAnalysing: LocalDate = LocalDate.parse(dateOfAnalysing)
        rating = VlRatingLowValueImpl(parsedDateOfAnalysing, reasoning)
    }

    override fun notAffected(
        dateOfAnalysing: String,
        reasoning: String,
    ) {
        val parsedDateOfAnalysing: LocalDate = LocalDate.parse(dateOfAnalysing)
        rating = VlRatingNotAffectedValueImpl(parsedDateOfAnalysing, reasoning)
    }

    override fun update(dependency: String): VlFixActionTargetVersionBuilder {
        toFix = VlToFixActionTargetVersionBuilder("update", dependency)
        return toFix as VlFixActionTargetVersionBuilder
    }

    override fun remove(dependency: String) {
        toFix = VlToFixRemoveActionBuilder("remove $dependency")
    }

    override fun replace(dependency: String): VlFixActionTargetDependencyBuilder {
        toFix = VlToFixActionTargetDependencyBuilder("replace", dependency)
        return toFix as VlFixActionTargetDependencyBuilder
    }

    override fun fixIn(vararg versions: VlReleaseValue) {
        fixIn = versions.toSet()
    }

    override fun action(context: VlActionContext.() -> Unit) =
        with(VlActionContextImpl()) {
            context()
            this@VlVulnerabilityContextImpl.actionContext += this
        }

    override fun overwrite(
        variant: VlVariantValue,
        vararg versions: VlReleaseValue,
    ): VlOverwriteBuilder = VlOverwriteBuilderImpl()

    override fun build(): VlVulnerabilityValue {
        val fixAction = toFix?.build() ?: VlFixActionValueImpl("")
        return VlVulnerabilityValueImpl(reportFor, reportBy, rating, fixAction, fixIn)
    }
}
