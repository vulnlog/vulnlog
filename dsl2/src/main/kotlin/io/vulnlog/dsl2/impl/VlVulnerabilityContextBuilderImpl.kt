package io.vulnlog.dsl2.impl

import io.vulnlog.dsl2.VlActionContext
import io.vulnlog.dsl2.VlFixActionTargetDependencyBuilder
import io.vulnlog.dsl2.VlFixActionTargetVersionBuilder
import io.vulnlog.dsl2.VlFixActionValue
import io.vulnlog.dsl2.VlOverwriteBuilder
import io.vulnlog.dsl2.VlRatingValue
import io.vulnlog.dsl2.VlReleaseValue
import io.vulnlog.dsl2.VlReportByValue
import io.vulnlog.dsl2.VlReportForValue
import io.vulnlog.dsl2.VlReporterValue
import io.vulnlog.dsl2.VlVariantValue
import io.vulnlog.dsl2.VlVulnerabilityContextBuilder
import java.time.LocalDate

@Suppress("TooManyFunctions")
class VlVulnerabilityContextBuilderImpl : VlVulnerabilityContextBuilder {
    private var reportFor: Set<VlReportForValue> = emptySet()
    private var reportBy: Set<VlReportByValue> = emptySet()
    private var rating: VlRatingValue? = null
    private var toFix: VlToFixActionBuilder? = null
    private var fixIn: Set<VlReleaseValue> = emptySet()

    private val actionContext: MutableList<VlActionContext> = mutableListOf()

    override fun reportFor(
        variant: VlVariantValue,
        vararg versions: VlReleaseValue,
    ) {
        reportFor = versions.map { VlReportForValueImpl(variant, it) }.toSet()
    }

    override fun reportBy(vararg reporters: VlReporterValue) {
        reportBy = reporters.map(VlReporterValue::name).map(::VlReportByValueImpl).toSet()
    }

    override fun critical(
        dateOfAnalysing: String,
        reasoning: String,
    ) {
        val parsedDateOfAnalysing: LocalDate = LocalDate.parse(dateOfAnalysing)
        rating = VlCriticalRatingValueImpl(parsedDateOfAnalysing, reasoning)
    }

    override fun high(
        dateOfAnalysing: String,
        reasoning: String,
    ) {
        val parsedDateOfAnalysing: LocalDate = LocalDate.parse(dateOfAnalysing)
        rating = VlHighRatingValueImpl(parsedDateOfAnalysing, reasoning)
    }

    override fun moderate(
        dateOfAnalysing: String,
        reasoning: String,
    ) {
        val parsedDateOfAnalysing: LocalDate = LocalDate.parse(dateOfAnalysing)
        rating = VlModerateRatingValueImpl(parsedDateOfAnalysing, reasoning)
    }

    override fun low(
        dateOfAnalysing: String,
        reasoning: String,
    ) {
        val parsedDateOfAnalysing: LocalDate = LocalDate.parse(dateOfAnalysing)
        rating = VlLowRatingValueImpl(parsedDateOfAnalysing, reasoning)
    }

    override fun notAffected(
        dateOfAnalysing: String,
        reasoning: String,
    ) {
        val parsedDateOfAnalysing: LocalDate = LocalDate.parse(dateOfAnalysing)
        rating = VlNotAffectedRatingValueImpl(parsedDateOfAnalysing, reasoning)
    }

    override fun update(dependency: String): VlFixActionTargetVersionBuilder {
        toFix = VlFixActionTargetVersionBuilderImpl("update", dependency)
        return toFix as VlFixActionTargetVersionBuilder
    }

    override fun remove(dependency: String) {
        toFix = VlFixRemoveActionValueImpl("remove $dependency")
    }

    override fun replace(dependency: String): VlFixActionTargetDependencyBuilder {
        toFix = VlFixActionTargetDependencyBuilderImpl("replace", dependency)
        return toFix as VlFixActionTargetDependencyBuilder
    }

    override fun fixIn(vararg versions: VlReleaseValue) {
        fixIn = versions.toSet()
    }

    override fun action(context: VlActionContext.() -> Unit) =
        with(VlActionContextImpl()) {
            context()
            this@VlVulnerabilityContextBuilderImpl.actionContext += this
        }

    override fun overwrite(
        variant: VlVariantValue,
        vararg versions: VlReleaseValue,
    ): VlOverwriteBuilder = VlOverwriteBuilderImpl()

    fun build(): VlFixActionValue = toFix?.build() ?: VlFixActionValueImpl("empty")
}
