package dev.vulnlog.dslinterpreter.impl

import dev.vulnlog.dsl.AnalysisData
import dev.vulnlog.dsl.ExecutionData2
import dev.vulnlog.dsl.ReleaseBranch
import dev.vulnlog.dsl.ReleaseBranchData
import dev.vulnlog.dsl.ReleaseBranchDataImpl
import dev.vulnlog.dsl.ReportData
import dev.vulnlog.dsl.TaskAction
import dev.vulnlog.dsl.VlVulnerabilityContext
import dev.vulnlog.dsl.VlVulnerabilityDslRoot
import dev.vulnlog.dsl.VulnlogAnalysisData
import dev.vulnlog.dsl.VulnlogData
import dev.vulnlog.dsl.VulnlogExecutionData
import dev.vulnlog.dsl.VulnlogExecutionDataEmpty
import dev.vulnlog.dsl.VulnlogExecutionDataImpl
import dev.vulnlog.dsl.VulnlogReportData
import dev.vulnlog.dsl.VulnlogTaskData
import dev.vulnlog.dsl.VulnlogTaskDataEmpty
import dev.vulnlog.dsl.VulnlogTaskDataImpl

class VlVulnerabilityDslRootImpl : VlVulnerabilityDslRoot {
    override val data = mutableListOf<VulnlogData>()

    override fun vuln(
        id: String,
        block: VlVulnerabilityContext.() -> Unit,
    ): VulnlogData = createVulnlogData(listOf(id), block)

    override fun vuln(
        vararg id: String,
        block: VlVulnerabilityContext.() -> Unit,
    ): VulnlogData = createVulnlogData(id.toList(), block)

    private fun createVulnlogData(
        id: List<String>,
        block: VlVulnerabilityContext.() -> Unit,
    ): VulnlogData =
        with(VlVulnerabilityContextImpl()) {
            block()

            val reportData = aBuilder.value.reportData
            val analysisData = tBuilder.value.analysisData
            val taskData = eBuilder.value.taskData
            val executionData = eBuilder.value.build()

            val report: VulnlogReportData? = reportFromData(reportData)
            val analysis: VulnlogAnalysisData? = analysisFromData(analysisData)

            val task: VulnlogTaskData =
                if (taskData.tasks.isEmpty()) {
                    VulnlogTaskDataEmpty
                } else {
                    val taskActionsToReleaseBranches: Map<TaskAction, List<ReleaseBranchData>> =
                        taskData.tasks.associate { task ->
                            task.taskAction to task.releases.map(ReleaseBranch::name).map(::ReleaseBranchDataImpl)
                        }
                    VulnlogTaskDataImpl(taskActionsToReleaseBranches)
                }

            val execution: VulnlogExecutionData =
                if (executionData.executions.isEmpty()) {
                    VulnlogExecutionDataEmpty
                } else {
                    val executionData2 =
                        executionData.executions.map { execution ->
                            ExecutionData2(
                                execution.action,
                                execution.duration,
                                execution.releases.map(ReleaseBranch::name).map(::ReleaseBranchDataImpl),
                            )
                        }
                    VulnlogExecutionDataImpl(executionData2)
                }

            val vulnlogData = VulnlogData(id, report, analysis, task, execution)
            data += vulnlogData
            vulnlogData
        }

    private fun reportFromData(reportData: ReportData) =
        if (reportData.reporter == null ||
            reportData.awareOfAt == null ||
            reportData.affectedReleases.isEmpty()
        ) {
            null
        } else {
            VulnlogReportDataImpl(
                reportData.reporter!!,
                reportData.awareOfAt!!,
                reportData.affectedReleases.map { ReleaseBranchDataImpl(it.name) },
            )
        }

    private fun analysisFromData(analysisData: AnalysisData) =
        if (analysisData.analysedAt == null ||
            analysisData.verdict == null ||
            analysisData.reasoning == null
        ) {
            null
        } else {
            VulnlogAnalysisDataImpl(
                analysisData.analysedAt!!,
                analysisData.verdict!!,
                analysisData.reasoning!!,
            )
        }
}
