package dev.vulnlog.dslinterpreter.service

import dev.vulnlog.dsl.ReleaseBranch
import dev.vulnlog.dsl.ReleaseBranchData
import dev.vulnlog.dsl.TaskAction
import dev.vulnlog.dsl.VulnerabilityData
import dev.vulnlog.dsl.VulnlogAnalysisData
import dev.vulnlog.dsl.VulnlogExecution
import dev.vulnlog.dsl.VulnlogExecutionData
import dev.vulnlog.dsl.VulnlogReportData
import dev.vulnlog.dsl.VulnlogTaskData
import dev.vulnlog.dslinterpreter.impl.DslAnalysisData
import dev.vulnlog.dslinterpreter.impl.DslExecutionData
import dev.vulnlog.dslinterpreter.impl.DslReportData
import dev.vulnlog.dslinterpreter.impl.DslTaskData
import dev.vulnlog.dslinterpreter.impl.ReleaseBranchDataImpl
import dev.vulnlog.dslinterpreter.impl.VulnlogAnalysisDataImpl
import dev.vulnlog.dslinterpreter.impl.VulnlogExecutionDataImpl
import dev.vulnlog.dslinterpreter.impl.VulnlogReportDataImpl
import dev.vulnlog.dslinterpreter.impl.VulnlogTaskDataImpl

class VulnerabilityServiceImpl(private val vulnerabilityDataRepository: MutableList<VulnerabilityData>) :
    VulnerabilityService {
    override fun createVulnerability(inputData: VulnerabilityServiceInputData): VulnerabilityData {
        val report: VulnlogReportData? = reportFromData(inputData.dslReportData)
        val analysis: VulnlogAnalysisData? = analysisFromData(inputData.dslAnalysisData)
        val task: VulnlogTaskData? = taskFromData(inputData.dslTaskData)
        val execution: VulnlogExecutionData? = executionFromData(inputData.dslExecutionData)

        val vulnerabilityData = VulnerabilityData(inputData.id, report, analysis, task, execution)
        vulnerabilityDataRepository += vulnerabilityData
        return vulnerabilityData
    }

    private fun reportFromData(dslReportData: DslReportData) =
        if (dslReportData.reporter == null ||
            dslReportData.awareOfAt == null ||
            dslReportData.affectedReleases.isEmpty()
        ) {
            null
        } else {
            VulnlogReportDataImpl(
                dslReportData.reporter,
                dslReportData.awareOfAt,
                dslReportData.affectedReleases.map { ReleaseBranchDataImpl(it.name) },
            )
        }

    private fun analysisFromData(dslAnalysisData: DslAnalysisData) =
        if (dslAnalysisData.analysedAt == null ||
            dslAnalysisData.verdict == null ||
            dslAnalysisData.reasoning == null
        ) {
            null
        } else {
            VulnlogAnalysisDataImpl(
                dslAnalysisData.analysedAt,
                dslAnalysisData.verdict!!,
                dslAnalysisData.reasoning!!,
            )
        }

    private fun taskFromData(dslTaskData: DslTaskData) =
        if (dslTaskData.analysisData == null || dslTaskData.tasks.isEmpty()) {
            null
        } else {
            val taskActionsToReleaseBranches: Map<TaskAction, List<ReleaseBranchData>> =
                dslTaskData.tasks.associate { task ->
                    task.taskAction to task.releases.map(ReleaseBranch::name).map(::ReleaseBranchDataImpl)
                }
            VulnlogTaskDataImpl(taskActionsToReleaseBranches)
        }

    private fun executionFromData(dslExecutionData: DslExecutionData) =
        if (dslExecutionData.executions.isEmpty()) {
            null
        } else {
            val vulnlogExecution =
                dslExecutionData.executions.map { execution ->
                    VulnlogExecution(
                        execution.action,
                        execution.duration,
                        execution.releases.map(ReleaseBranch::name)
                            .map(::ReleaseBranchDataImpl),
                    )
                }
            VulnlogExecutionDataImpl(vulnlogExecution)
        }
}
