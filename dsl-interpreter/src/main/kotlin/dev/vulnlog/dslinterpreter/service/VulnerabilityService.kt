package dev.vulnlog.dslinterpreter.service

import dev.vulnlog.dsl.InvolvedReleaseVersion
import dev.vulnlog.dsl.ReleaseBranch
import dev.vulnlog.dsl.ReleaseBranchData
import dev.vulnlog.dsl.TaskAction
import dev.vulnlog.dsl.VulnerabilityData
import dev.vulnlog.dsl.VulnlogAnalysisData
import dev.vulnlog.dsl.VulnlogExecutionData
import dev.vulnlog.dsl.VulnlogFixExecution
import dev.vulnlog.dsl.VulnlogReportData
import dev.vulnlog.dsl.VulnlogSuppressPermanentExecution
import dev.vulnlog.dsl.VulnlogSuppressUntilExecution
import dev.vulnlog.dsl.VulnlogSuppressUntilNextPublicationExecution
import dev.vulnlog.dsl.VulnlogTaskData
import dev.vulnlog.dslinterpreter.impl.DslAnalysisData
import dev.vulnlog.dslinterpreter.impl.DslExecutionData
import dev.vulnlog.dslinterpreter.impl.DslReportData
import dev.vulnlog.dslinterpreter.impl.DslTaskData
import dev.vulnlog.dslinterpreter.impl.FixedExecution
import dev.vulnlog.dslinterpreter.impl.ReleaseBranchDataImpl
import dev.vulnlog.dslinterpreter.impl.SuppressionDateExecution
import dev.vulnlog.dslinterpreter.impl.SuppressionEventExecution
import dev.vulnlog.dslinterpreter.impl.SuppressionPermanentExecution
import dev.vulnlog.dslinterpreter.impl.VulnlogAnalysisDataImpl
import dev.vulnlog.dslinterpreter.impl.VulnlogExecutionDataImpl
import dev.vulnlog.dslinterpreter.impl.VulnlogReportDataImpl
import dev.vulnlog.dslinterpreter.impl.VulnlogTaskDataImpl

interface VulnerabilityService {
    fun createVulnerability(inputData: VulnerabilityServiceInputData): VulnerabilityData
}

data class VulnerabilityServiceInputData(
    val id: List<String>,
    val dslReportData: DslReportData,
    val dslAnalysisData: DslAnalysisData,
    val dslTaskData: DslTaskData,
    val dslExecutionData: DslExecutionData,
)

class VulnerabilityServiceImpl(
    private val affectedVersionsService: AffectedVersionsService,
    private val vulnerabilityDataRepository: MutableList<VulnerabilityData>,
) :
    VulnerabilityService {
    override fun createVulnerability(inputData: VulnerabilityServiceInputData): VulnerabilityData {
        val report: VulnlogReportData? = reportFromData(inputData.dslReportData)

        val involvedVersions: Map<ReleaseBranchData, InvolvedReleaseVersion> =
            report?.let {
                val reportForBranches =
                    report.affected.map { report.awareAt to it }
                        .map { (affectedDate, branchData) -> ReportForBranch(affectedDate, branchData) }
                affectedVersionsService.findInvolvedVersions(reportForBranches)
            } ?: emptyMap()

        val analysis: VulnlogAnalysisData? = analysisFromData(inputData.dslAnalysisData)
        val task: VulnlogTaskData? = taskFromData(inputData.dslTaskData)
        val execution: VulnlogExecutionData? = executionFromData(inputData.dslExecutionData, involvedVersions)

        val vulnerabilityData =
            VulnerabilityData(inputData.id, report, analysis, task, execution, involvedVersions)
        vulnerabilityDataRepository += vulnerabilityData
        return vulnerabilityData
    }

    private fun reportFromData(dslReportData: DslReportData) =
        if (dslReportData.reporters.isEmpty() ||
            dslReportData.awareOfAt == null ||
            dslReportData.affectedReleases.isEmpty()
        ) {
            null
        } else {
            VulnlogReportDataImpl(
                dslReportData.reporters,
                dslReportData.awareOfAt,
                dslReportData.affectedReleases.map { ReleaseBranchDataImpl(it.name) },
            )
        }

    private fun analysisFromData(dslAnalysisData: DslAnalysisData) =
        if (dslAnalysisData.analysedAt == null ||
            dslAnalysisData.verdict == null ||
            dslAnalysisData.reasoning == null
        ) {
            null
        } else {
            VulnlogAnalysisDataImpl(
                dslAnalysisData.analysedAt,
                dslAnalysisData.verdict!!,
                dslAnalysisData.reasoning!!,
            )
        }

    private fun taskFromData(dslTaskData: DslTaskData) =
        if (dslTaskData.analysisData == null || dslTaskData.tasks.isEmpty()) {
            null
        } else {
            val taskActionsToReleaseBranches: Map<TaskAction, List<ReleaseBranchData>> =
                dslTaskData.tasks.associate { task ->
                    task.taskAction to task.releases.map(ReleaseBranch::name).map(::ReleaseBranchDataImpl)
                }
            VulnlogTaskDataImpl(taskActionsToReleaseBranches)
        }

    private fun executionFromData(
        dslExecutionData: DslExecutionData,
        involvedVersions: Map<ReleaseBranchData, InvolvedReleaseVersion>,
    ) = if (dslExecutionData.executions.isEmpty()) {
        null
    } else {
        val vulnlogExecution =
            dslExecutionData.executions.map { execution ->
                val releaseBranch = execution.releases.map(ReleaseBranch::name).map(::ReleaseBranchDataImpl)
                when (execution) {
                    is FixedExecution -> VulnlogFixExecution(execution.action, releaseBranch, execution.fixDate)
                    is SuppressionDateExecution ->
                        VulnlogSuppressUntilExecution(
                            execution.action,
                            releaseBranch,
                            execution.suppressUntilDate,
                        )

                    is SuppressionEventExecution ->
                        VulnlogSuppressUntilNextPublicationExecution(
                            execution.action,
                            releaseBranch,
                            involvedVersions,
                        )

                    is SuppressionPermanentExecution ->
                        VulnlogSuppressPermanentExecution(
                            execution.action,
                            releaseBranch,
                        )
                }
            }
        VulnlogExecutionDataImpl(vulnlogExecution)
    }
}
