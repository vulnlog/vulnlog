package dev.vulnlog.dslinterpreter.service

import dev.vulnlog.common.ReleaseBranchDataImpl
import dev.vulnlog.dsl.InvolvedReleaseVersion
import dev.vulnlog.dsl.ReleaseBranch
import dev.vulnlog.dsl.ReleaseBranchData
import dev.vulnlog.dsl.TaskAction
import dev.vulnlog.dsl.VulnerabilityData
import dev.vulnlog.dsl.VulnlogAnalysisData
import dev.vulnlog.dsl.VulnlogExecution
import dev.vulnlog.dsl.VulnlogExecutionData
import dev.vulnlog.dsl.VulnlogFixExecution
import dev.vulnlog.dsl.VulnlogReportData
import dev.vulnlog.dsl.VulnlogSuppressPermanentExecution
import dev.vulnlog.dsl.VulnlogSuppressUntilExecution
import dev.vulnlog.dsl.VulnlogSuppressUntilNextPublicationExecution
import dev.vulnlog.dsl.VulnlogTaskData
import dev.vulnlog.dslinterpreter.impl.DslAnalysisData
import dev.vulnlog.dslinterpreter.impl.DslExecutionData
import dev.vulnlog.dslinterpreter.impl.DslReportData
import dev.vulnlog.dslinterpreter.impl.DslTaskData
import dev.vulnlog.dslinterpreter.impl.FixedExecution
import dev.vulnlog.dslinterpreter.impl.SuppressionDateExecution
import dev.vulnlog.dslinterpreter.impl.SuppressionEventExecution
import dev.vulnlog.dslinterpreter.impl.SuppressionPermanentExecution
import dev.vulnlog.dslinterpreter.impl.VulnlogAnalysisDataImpl
import dev.vulnlog.dslinterpreter.impl.VulnlogExecutionDataImpl
import dev.vulnlog.dslinterpreter.impl.VulnlogReportDataImpl
import dev.vulnlog.dslinterpreter.impl.VulnlogTaskDataImpl

interface VulnerabilityService {
    fun createVulnerability(inputData: VulnerabilityServiceInputData): VulnerabilityData
}

data class VulnerabilityServiceInputData(
    val id: List<String>,
    val dslReportData: DslReportData,
    val dslAnalysisData: DslAnalysisData,
    val dslTaskData: DslTaskData,
    val dslExecutionData: DslExecutionData,
)

class VulnerabilityServiceImpl(
    private val affectedVersionsService: AffectedVersionsService,
) : VulnerabilityService {
    override fun createVulnerability(inputData: VulnerabilityServiceInputData): VulnerabilityData {
        val report: VulnlogReportData? = reportFromData(inputData.dslReportData)

        // TODO also include fixedAt date here
        val involvedVersions: Map<ReleaseBranchData, InvolvedReleaseVersion> =
            report?.let {
                val reportForBranches =
                    report.affected
                        .map { report.awareAt to it }
                        .map { (affectedDate, branchData) -> ReportForBranch(affectedDate, branchData) }
                affectedVersionsService.findInvolvedVersions(reportForBranches)
            } ?: emptyMap()

        val analysis: VulnlogAnalysisData? = analysisFromData(inputData.dslAnalysisData)
        val task: VulnlogTaskData? = taskFromData(inputData.dslTaskData)
        val execution: VulnlogExecutionData? = executionFromData(inputData.dslExecutionData, involvedVersions)

        return VulnerabilityData(inputData.id, report, analysis, task, execution, involvedVersions)
    }

    private fun reportFromData(dslReportData: DslReportData) =
        if (dslReportData.reporters.isEmpty() ||
            dslReportData.awareOfAt == null ||
            dslReportData.affectedReleases.isEmpty()
        ) {
            null
        } else {
            VulnlogReportDataImpl(
                dslReportData.reporters,
                dslReportData.awareOfAt,
                dslReportData.affectedReleases.map { ReleaseBranchDataImpl(it.name) },
            )
        }

    private fun analysisFromData(analysis: DslAnalysisData) =
        if (analysis.analysedAt == null || analysis.verdict == null || analysis.reasoning == null) {
            null
        } else {
            VulnlogAnalysisDataImpl(analysis.analysedAt, analysis.verdict!!, analysis.reasoning!!)
        }

    private fun taskFromData(task: DslTaskData) =
        if (task.analysisData == null || task.tasks.isEmpty()) {
            null
        } else {
            val taskActionsToReleaseBranches: Map<TaskAction, List<ReleaseBranchData>> =
                task.tasks
                    .associate { it.taskAction to it.releases.map(ReleaseBranch::name).map(::ReleaseBranchDataImpl) }
            VulnlogTaskDataImpl(taskActionsToReleaseBranches)
        }

    private fun executionFromData(
        dslExecutionData: DslExecutionData,
        involvedVersions: Map<ReleaseBranchData, InvolvedReleaseVersion>,
    ) = if (dslExecutionData.executions.isEmpty()) {
        null
    } else {
        val vulnlogExecutions: List<VulnlogExecution> = vulnlogExecutions(dslExecutionData, involvedVersions)
        VulnlogExecutionDataImpl(vulnlogExecutions)
    }

    private fun vulnlogExecutions(
        dslExecutionData: DslExecutionData,
        involvedVersions: Map<ReleaseBranchData, InvolvedReleaseVersion>,
    ) = dslExecutionData.executions.map { execution ->
        val releaseBranch = execution.releases.map(ReleaseBranch::name).map(::ReleaseBranchDataImpl)
        val action = execution.action
        when (execution) {
            is FixedExecution -> VulnlogFixExecution(action, releaseBranch, execution.fixDate)
            is SuppressionDateExecution ->
                VulnlogSuppressUntilExecution(
                    action,
                    releaseBranch,
                    execution.suppressUntilDate,
                )

            is SuppressionEventExecution ->
                VulnlogSuppressUntilNextPublicationExecution(
                    action,
                    releaseBranch,
                    involvedVersions,
                )

            is SuppressionPermanentExecution -> VulnlogSuppressPermanentExecution(action, releaseBranch)
        }
    }
}
